# 消息队列

我用redis的stream实现的

## stream

```go
//添加数据
err := s.RdbMq.XAdd(ctx, &redis.XAddArgs{
    Stream: "task_queue",        // 流名称
    MaxLen: 1000,              // 限制流的最大长度
    ID: "*",                   // 自动生成ID，或指定特定ID
    Values: map[string]interface{}{
        "task_id": "20231205000000-abc123",
        "task_type": "add_luggage",
    },
}).Err()


// 创建消费者组
err := s.RdbMq.XGroupCreate(ctx, "task_queue", "processor", "0").Err()
// 参数说明：
// task_queue: 流名称
// processor: 消费者组名称
// "0": 表示从第一条消息开始读取
// "$": 表示只接收新消息

// 消费者组读取消息
result, err := s.RdbMq.XReadGroup(ctx, &redis.XReadGroupArgs{
    Group:    "processor",      // 消费者组名
    Consumer: "worker_1",      // 消费者名
    Streams:  []string{"task_queue", ">"},  // > 表示未读的新消息
    Count:   10,             // 每次读取的消息数量
    Block:   time.Second * 5, // 阻塞时间
}).Result()

// 确认消息处理完成
err := s.RdbMq.XAck(ctx, "task_queue", "processor", "1607230400000-0").Err()

```

## 造工具

先造点相关的工具

```go
type Task struct {
	ID         string                 `json:"id"`
	Type       string                 `json:"type"`   // 操作类型
	Data       map[string]interface{} `json:"data"`   // 请求数据
	Status     string                 `json:"status"` // pending, processing, completed, failed
	Result     interface{}            `json:"result"` // 操作结果
	Error      string                 `json:"error"`  // 错误信息
	CreateAt   time.Time              `json:"create_at"`
	CompleteAt *time.Time             `json:"complete_at,omitempty"`
}

// AddTask 提交任务到队列
func AddTask(ctx context.Context, s *services.Services, taskType string, data map[string]interface{}) (string, error) {
	// 生成任务ID
	taskID := generateTaskID()

	// 创建任务
	task := Task{
		ID:       taskID,
		Type:     taskType,
		Data:     data,
		Status:   "pending",
		CreateAt: time.Now(),
	}

	// 保存任务到Redis（用于状态查询）
	taskBytes, _ := json.Marshal(task)
	if err := s.RdbMq.Set(ctx, "task:"+taskID, taskBytes, time.Hour*24).Err(); err != nil {
		return "", err
	}

	// 将任务添加到队列
	err := s.RdbMq.XAdd(ctx, &redis.XAddArgs{
		Stream: "task_queue",
		Values: map[string]interface{}{
			"task_id": taskID,
		},
	}).Err()
	if err != nil {
		return "", err
	}

	return taskID, nil
}

// GetTaskStatus 查询任务状态
func GetTaskStatus(ctx context.Context, s *services.Services, taskID string) (*Task, error) {
	taskBytes, err := s.RdbMq.Get(ctx, "task:"+taskID).Result()
	if err != nil {
		return nil, err
	}

	var task Task
	if err := json.Unmarshal([]byte(taskBytes), &task); err != nil {
		return nil, err
	}

	return &task, nil
}

// UpdateTaskStatus 更新任务状态
func UpdateTaskStatus(ctx context.Context, s *services.Services, taskID, status string, result interface{}, errMsg string) {
	task, err := GetTaskStatus(ctx, s, taskID)
	if err != nil {
		log.Println("获取任务失败:", err.Error())
		return
	}

	task.Status = status
	task.Result = result
	if status == "completed" {
		now := time.Now()
		task.CompleteAt = &now
	}
	if errMsg != "" {
		task.Error = errMsg
	}

	taskBytes, _ := json.Marshal(task)
	if err := s.RdbMq.Set(ctx, "task:"+taskID, taskBytes, time.Hour*24).Err(); err != nil {
		log.Println("更新任务状态失败:", err.Error())
	}
}

// GetNextTask 从队列获取下一个任务
func GetNextTask(ctx context.Context, s *services.Services, group, consumer string) (string, error) {
	// 确保消费者组存在
	err := s.RdbMq.XGroupCreate(ctx, "task_queue", group, "0").Err()
	if err != nil {
		return "", err
	}

	// 读取任务
	result, err := s.RdbMq.XReadGroup(ctx, &redis.XReadGroupArgs{
		Group:    group,
		Consumer: consumer,
		Streams:  []string{"task_queue", ">"},
		Count:    1,
		Block:    time.Second * 5,
	}).Result()

	if err != nil || len(result) == 0 || len(result[0].Messages) == 0 {
		return "", nil // 没有任务
	}

	// 获取任务ID
	taskID, ok := result[0].Messages[0].Values["task_id"].(string)
	if !ok {
		return "", errors.New("无效的任务消息")
	}

	// 确认消息
	msgID := result[0].Messages[0].ID
	if err := s.RdbMq.XAck(ctx, "task_queue", group, msgID).Err(); err != nil {
		log.Println("确认任务消息失败:", err.Error())
	}

	return taskID, nil
}

// generateTaskID 简单的任务ID生成器
func generateTaskID() string {
	return time.Now().Format("20060102150405") + "-" + randomString(6)
}

// randomString 简单的随机字符串生成器
func randomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[time.Now().UnixNano()%int64(len(charset))]
	}
	return string(b)
}

```

## 主要逻辑

再写具体的处理逻辑

```go
package message_queue

import (
	"context"
	"errors"
	"hotel/models"
	"hotel/services"
	"log"
	"time"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

// StartTaskProcessor 启动任务处理器
func StartTaskProcessor(ctx context.Context, s *services.Services) {
	log.Println("启动任务处理器...")
	go func() {
		for {
			select {
			case <-ctx.Done():
				log.Println("任务处理器停止")
				return
			default:
				// 获取下一个任务
				taskID, err := GetNextTask(ctx, s, "processor", "processor_1")
				if err != nil {
					log.Println("获取任务失败:", err)
					continue
				}

				if taskID == "" {
					// 没有任务，稍后重试
					time.Sleep(time.Millisecond * 500)
					continue
				}

				// 处理任务
				log.Println("开始处理任务:", taskID)
				ProcessTask(ctx, s, taskID)
			}
		}
	}()
}

// ProcessTask 处理任务
func ProcessTask(ctx context.Context, s *services.Services, taskID string) {
	// 更新任务状态为处理中
	UpdateTaskStatus(ctx, s, taskID, "processing", nil, "")

	// 获取任务详情
	task, err := GetTaskStatus(ctx, s, taskID)
	if err != nil {
		UpdateTaskStatus(ctx, s, taskID, "failed", nil, "获取任务失败: "+err.Error())
		return
	}

	// 根据任务类型执行相应操作
	var result interface{}
	var processErr error

	switch task.Type {
	case "add_luggage":
		result, processErr = processAddLuggage(s, task.Data)
	case "delete_luggage":
		result, processErr = processDeleteLuggage(s, task.Data)
	case "update_luggage":
		result, processErr = processUpdateLuggage(s, task.Data)
	default:
		processErr = errors.New("未知任务类型: " + task.Type)
	}

	// 更新任务状态
	if processErr != nil {
		UpdateTaskStatus(ctx, s, taskID, "failed", nil, processErr.Error())
		log.Printf("任务 %s 处理失败: %v", taskID, processErr)
	} else {
		UpdateTaskStatus(ctx, s, taskID, "completed", result, "")
		log.Printf("任务 %s 处理成功", taskID)
	}
}

// processAddLuggage 处理添加行李任务
func processAddLuggage(s *services.Services, data map[string]interface{}) (interface{}, error) {
	// 解析请求数据
	guestName, ok := data["guest_name"].(string)
	if !ok {
		return nil, errors.New("客户姓名不能为空")
	}

	tag, _ := data["tag"].(string)
	weight, _ := data["weight"].(float32)
	status, _ := data["status"].(string)
	location, _ := data["location"].(string)

	// 先创建或获取客户记录
	var guest models.Guest
	result := s.DB.Where("guest_name = ?", guestName).First(&guest)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			// 客户不存在，创建新客户
			guest = models.Guest{
				Name: guestName,
			}
			if err := s.DB.Create(&guest).Error; err != nil {
				return nil, err
			}
		} else {
			// 其他查询错误
			return nil, result.Error
		}
	}

	// 创建行李记录
	luggage := models.Luggage{
		GuestID:  guest.ID,
		Tag:      tag,
		Weight:   weight,
		Status:   status,
		Location: location,
	}

	result = s.DB.Create(&luggage)
	if result.Error != nil {
		return nil, result.Error
	}

	// 返回成功结果
	return gin.H{
		"id":         luggage.ID,
		"guest_id":   luggage.GuestID,
		"guest_name": guestName,
		"tag":        luggage.Tag,
		"weight":     luggage.Weight,
		"status":     luggage.Status,
		"location":   luggage.Location,
	}, nil
}

// processDeleteLuggage 处理删除行李任务
func processDeleteLuggage(s *services.Services, data map[string]interface{}) (interface{}, error) {
	// 解析请求数据
	luggageID, ok := data["id"].(float64)
	if !ok {
		return nil, errors.New("行李ID不能为空")
	}

	// 检查行李是否存在
	var existingLuggage models.Luggage
	if err := s.DB.Where("status = ?", "寄存中").First(&existingLuggage, uint(luggageID)).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("行李记录不存在或已取出")
		}
		return nil, err
	}

	// 更新行李状态
	existingLuggage.Status = "已取出"
	existingLuggage.Location = "已取出"
	result := s.DB.Model(&models.Luggage{}).Where("id = ?", luggageID).Updates(existingLuggage)
	if result.Error != nil {
		return nil, result.Error
	}

	// 软删除记录
	if err := s.DB.Where("id = ?", luggageID).Delete(&models.Luggage{}).Error; err != nil {
		return nil, err
	}

	return gin.H{
		"success": true,
		"message": "行李删除成功",
	}, nil
}

// processUpdateLuggage 处理更新行李任务
func processUpdateLuggage(s *services.Services, data map[string]interface{}) (interface{}, error) {
	// 解析请求数据
	luggageID, ok := data["id"].(float64)
	if !ok {
		return nil, errors.New("行李ID不能为空")
	}

	// 先检查记录是否存在
	var existingLuggage models.Luggage
	if err := s.DB.First(&existingLuggage, uint(luggageID)).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("行李记录不存在")
		}
		return nil, err
	}

	// 更新字段
	if status, ok := data["status"].(string); ok {
		existingLuggage.Status = status
	}
	if location, ok := data["location"].(string); ok {
		existingLuggage.Location = location
	}

	// 执行更新
	result := s.DB.Model(&existingLuggage).Updates(existingLuggage)
	if result.Error != nil {
		return nil, result.Error
	}

	// 获取客户信息
	var guest models.Guest
	s.DB.First(&guest, existingLuggage.GuestID)

	return gin.H{
		"id":         existingLuggage.ID,
		"guest_id":   existingLuggage.GuestID,
		"guest_name": guest.Name,
		"tag":        existingLuggage.Tag,
		"weight":     existingLuggage.Weight,
		"status":     existingLuggage.Status,
		"location":   existingLuggage.Location,
	}, nil
}

```

