# 杂记

## 配置静态文件

```go
r.Static("/uploads", "./uploads")
```

可以直接访问，但是没有权限检查和日志记录、更快，适合可以公开的东西

| `/photos/:filename` | 单个冒号，**不能匹配斜杠**   | `/photos/abc.png`     | `abc.png`     |
| ------------------- | ---------------------------- | --------------------- | ------------- |
| `/photos/*filepath` | 星号通配符，**可以匹配斜杠** | `/photos/dir/abc.png` | `dir/abc.png` |

```go
func StaticDownloadPhoto(c *gin.Context) {
    filename := c.Param("filename")
    if filename == "" {
       c.JSON(http.StatusBadRequest, gin.H{
          "success": false,
          "message": "请提供文件地址",
       })
       return
    }
    //规范化路径，防止.和/，路径遍历
    cleanPath := filepath.Clean(filename)

    if strings.Contains(cleanPath, "..") {
       c.AbortWithStatus(http.StatusForbidden)
       return
    }

    localPath := fmt.Sprintf("./uploads/photos/%s", filename)

    // 检查文件是否存在
    if _, err := os.Stat(localPath); os.IsNotExist(err) {
       c.JSON(http.StatusNotFound, gin.H{
          "success": false,
          "message": "照片不存在",
       })
       return
    }

    // 返回文件
    c.File(localPath)

}
```

### 更完整的检查

```go
// Download 获取数据
func Download(c *gin.Context) {
	filename := c.Param("filename")
	name := c.Param("name")
	ty := c.Param("type")

	username, ok := c.Get("user_name")
	if !ok || username != name {
		c.JSON(http.StatusForbidden, gin.H{
			"success": false,
			"message": "无权访问",
		})
		return
	}

	// 1. ✅ 先构建完整路径
	path := filepath.Join("./uploads", name, ty, filename)

	// 2. ✅ 清理路径（消除 ../ 和多余的 /）
	cleanPath := filepath.Clean(path)

	// 3. ✅ 验证文件类型（白名单）
	if ty != "images" && ty != "models" {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"message": "无效的文件类型",
		})
		return
	}

	// 4. ✅ 验证文件名（检查清理后的路径）
	if strings.Contains(cleanPath, "..") ||
		strings.Contains(cleanPath, "\x00") { // 检查空字节
		c.JSON(http.StatusForbidden, gin.H{
			"success": false,
			"message": "非法的文件名",
		})
		util.Logger.WithFields(logrus.Fields{
			"path":      cleanPath,
			"user_name": username,
		}).Warn("路径遍历攻击尝试")
		return
	}

	// 5. ✅ 验证文件扩展名
	ext := filepath.Ext(cleanPath)
	allowedExts := map[string]bool{
		".jpg": true, ".jpeg": true, ".png": true, ".gif": true,
		".obj": true, ".glb": true, ".gltf": true, ".fbx": true, ".stl": true,
	}
	if !allowedExts[ext] {
		c.JSON(http.StatusBadRequest, gin.H{
			"success": false,
			"message": "不支持的文件类型",
		})
		return
	}

	// 6. ✅ 验证路径是否在允许的目录内
	uploadsDir := filepath.Clean("./uploads")
	relPath, err := filepath.Rel(uploadsDir, cleanPath)
	if err != nil || strings.HasPrefix(relPath, "..") {
		c.JSON(http.StatusForbidden, gin.H{
			"success": false,
			"message": "非法的路径",
		})
		util.Logger.WithFields(logrus.Fields{
			"path":    cleanPath,
			"relPath": relPath,
			"error":   err,
		}).Warn("路径遍历攻击尝试")
		return
	}

	// 7. ✅ 检查文件是否存在
	if _, err := os.Stat(cleanPath); os.IsNotExist(err) {
		c.JSON(http.StatusNotFound, gin.H{
			"success": false,
			"message": "文件不存在",
		})
		util.Logger.WithFields(logrus.Fields{
			"filename": filename,
			"path":     cleanPath,
		}).Warn("文件不存在")
		return
	}

	// 8. ✅ 返回文件
	c.File(cleanPath)
}
```

