# 日志分级

## 本文所用包

```go
"github.com/sirupsen/logrus"
"gopkg.in/natefinch/lumberjack.v2"
```

## 日志等级

```go
//1. DEBUG（调试）
用途：记录详细的调试信息，帮助开发者了解程序内部运行状态
特点：信息非常详细，通常只在开发和调试时使用
示例：
DEBUG: 开始处理用户请求，请求ID: 12345
DEBUG: 数据库查询语句: SELECT * FROM users WHERE id = 10
DEBUG: 内存使用情况: 已用 256MB，总计 512MB
//2. INFO（信息）
用途：记录程序正常运行的重要信息
特点：比DEBUG信息少，但记录了关键的业务流程
示例：
INFO: 服务器启动成功，监听端口: 8080
INFO: 用户登录成功，用户名: zhangsan
INFO: 订单创建成功，订单号: ORD20231211001
//3. WARN（警告）
用途：记录可能的问题，但不影响程序正常运行
特点：提醒开发者注意某些异常情况
示例：
WARN: 数据库连接池接近满载，当前使用 95/100
WARN: 用户尝试登录失败，用户名: zhangsan，IP: 192.168.1.100
WARN: 配置文件中缺少可选参数 'timeout'，使用默认值 30s
//4. ERROR（错误）
用途：记录处理过程中出现的错误，但不影响程序继续运行
特点：表示某个操作失败，但程序整体还能继续
示例：
ERROR: 无法连接到数据库服务器，5秒后重试
ERROR: 发送邮件失败，收件人: user@example.com
ERROR: 文件上传失败，文件太大，超过10MB限制
//5. FATAL（致命）
用途：记录严重错误，会导致程序退出
特点：表示系统无法继续运行
示例：
FATAL: 配置文件不存在，程序无法启动
FATAL: 内存不足，无法分配资源
FATAL: 无法绑定到端口 8080，权限不足
```



## 具体代码

```go
//创建一个日志,Logger为全局变量
Logger = logrus.New()
//根据loglevel自动转换成相应的日志等级
level, err := logrus.ParseLevel(logLevel)
//设置日志记录等级，只有大于等于日志等级的日志，才会被记录
Logger.SetLevel(level)
// 设置日志格式，这里是json格式
Logger.SetFormatter(&logrus.JSONFormatter{
	TimestampFormat: "2006-01-02 15:04:05",
})
// 日志轮转
		//lumberjack.Logger 是一个日志轮转库，用于管理日志文件
		//Filename 日志文件路径
		//MaxSize 单个日志文件的最大大小(MB)
		//MaxBackups 保留的旧日志文件数量
		//MaxAge 保留日志文件的最大天数
		//Compress 是否压缩旧日志文件
		Logger.SetOutput(&lumberjack.Logger{
			Filename:   filePath,
			MaxSize:    maxSize,    // MB
			MaxBackups: maxBackups, // 保留的旧日志文件数量
			MaxAge:     maxAge,     // 保留日志文件的最大天数
			Compress:   true,       // 压缩旧日志文件
		})
//io.MultiWriter() 创建一个写入器，可以将数据同时写入多个写入器
		//os.Stdout 代表标准输出（控制台）
		//fileWriter 是文件写入器
		//这样设置后，日志会同时输出到控制台和文件

		Logger.SetOutput(io.MultiWriter(os.Stdout, fileWriter))
```

## 实例

```go
package util

import (
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/sirupsen/logrus"
	"gopkg.in/natefinch/lumberjack.v2"
)

var Logger *logrus.Logger

// InitLogger 初始化日志
func InitLogger(logLevel, output, filePath string, maxSize, maxBackups, maxAge int) {
	Logger = logrus.New()

	// 设置日志级别
	level, err := logrus.ParseLevel(logLevel)
	if err != nil {
		level = logrus.InfoLevel
	}
	Logger.SetLevel(level)

	// 设置日志格式
	Logger.SetFormatter(&logrus.JSONFormatter{
		TimestampFormat: "2006-01-02 15:04:05",
	})

	// 设置输出，全部转换成小写
	switch strings.ToLower(output) {
	case "file":
		// 确保目录存在，函数的作用是获取路径的目录部分
		//os.Stat() 获取文件或目录的信息
		//os.IsNotExist(err) 检查错误是否表示文件/目录不存在
		//os.MkdirAll() 创建目录，包括所有必要的父目录
		//0755 是权限设置，表示所有者有读写执行权限，组和其他用户有读执行权限
		dir := filepath.Dir(filePath)
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			os.MkdirAll(dir, 0755)
		}

		// 日志轮转
		//lumberjack.Logger 是一个日志轮转库，用于管理日志文件
		//Filename 日志文件路径
		//MaxSize 单个日志文件的最大大小(MB)
		//MaxBackups 保留的旧日志文件数量
		//MaxAge 保留日志文件的最大天数
		//Compress 是否压缩旧日志文件
		Logger.SetOutput(&lumberjack.Logger{
			Filename:   filePath,
			MaxSize:    maxSize,    // MB
			MaxBackups: maxBackups, // 保留的旧日志文件数量
			MaxAge:     maxAge,     // 保留日志文件的最大天数
			Compress:   true,       // 压缩旧日志文件
		})
	case "both":
		// 同时输出到文件和控制台
		dir := filepath.Dir(filePath)
		if _, err := os.Stat(dir); os.IsNotExist(err) {
			os.MkdirAll(dir, 0755)
		}

		fileWriter := &lumberjack.Logger{
			Filename:   filePath,
			MaxSize:    maxSize,
			MaxBackups: maxBackups,
			MaxAge:     maxAge,
			Compress:   true,
		}
		//io.MultiWriter() 创建一个写入器，可以将数据同时写入多个写入器
		//os.Stdout 代表标准输出（控制台）
		//fileWriter 是文件写入器
		//这样设置后，日志会同时输出到控制台和文件

		Logger.SetOutput(io.MultiWriter(os.Stdout, fileWriter))
	default: // console
		Logger.SetOutput(os.Stdout)
	}
}

```

## 输出样例

```go
"github.com/sirupsen/logrus"

logger.Logger.WithFields(logrus.Fields{
			"request_id": requestID,
			"method":     c.Request.Method,
			"path":       c.Request.URL.Path,
			"status":     c.Writer.Status(),
			"duration":   time.Since(start),
		}).Info("请求处理完成")
```

